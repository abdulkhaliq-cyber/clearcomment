datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?
  accounts      Account[]
  sessions      Session[]
  createdAt     DateTime  @default(now())
  pages         FacebookPage[]
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model FacebookPage {
  id                String   @id @default(cuid())
  userId            String
  user              User     @relation(fields: [userId], references: [id])
  pageId            String   @unique
  pageName          String
  pageAccessToken   String   @db.Text
  moderationEnabled Boolean  @default(true)
  createdAt         DateTime @default(now())
  logs              ModerationLog[]
  comments          Comment[]
  rules             ModerationRule[]

  @@index([userId])
  @@index([pageId])
}

model ModerationRule {
  id        String   @id @default(cuid())
  pageId    String
  page      FacebookPage @relation(fields: [pageId], references: [id])
  type            String   // "BLOCK_KEYWORD", "AUTO_REPLY", "BLOCK_LINK", "BLOCK_IMAGE", "REGEX_MATCH"
  keyword         String?  // For BLOCK_KEYWORD (e.g., "spam", "badword")
  replyText       String?  // For AUTO_REPLY
  ruleConfig      Json?    // For advanced config (e.g., exact match, case sensitivity)
  isEnabled       Boolean  @default(true)
  lastTriggeredAt DateTime?
  createdAt       DateTime @default(now())

  @@index([pageId])
}

model WebhookEventLog {
  id        String   @id @default(cuid())
  eventId   String   @unique // Facebook Event ID or Comment ID to dedupe
  pageId    String
  eventType String   // e.g., "comment_add", "comment_edit"
  receivedAt DateTime @default(now())

  @@index([eventId])
}

model ModerationQueue {
  id        String   @id @default(cuid())
  payload   Json     // Stores the full event body
  status    String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  attempts  Int      @default(0)
  error     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

model Comment {
  id          String   @id // Facebook Comment ID
  postId      String
  pageId      String
  page        FacebookPage @relation(fields: [pageId], references: [id])
  message     String   @db.Text
  authorName  String
  authorId    String
  isHidden      Boolean  @default(false)
  sentiment     String?  // "POSITIVE", "NEGATIVE", "NEUTRAL"
  sentimentScore Float?  // -5 to 5
  createdAt     DateTime @default(now()) // DB creation time
  fbCreatedTime DateTime // Facebook creation time

  @@index([pageId])
  @@index([postId])
}

model ModerationLog {
  id          String   @id @default(cuid())
  pageId      String
  page        FacebookPage @relation(fields: [pageId], references: [id])
  action      String   // "HIDE", "DELETE", "REPLY", "UNHIDE", "LIKE", "UNLIKE"
  commentId   String
  commentText String?
  ruleId      String?
  apiResponse Json?
  success     Boolean  @default(true)
  performedAt DateTime @default(now())

  @@index([pageId])
}
